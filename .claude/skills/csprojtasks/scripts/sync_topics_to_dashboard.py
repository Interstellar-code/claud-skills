#!/usr/bin/env python3
"""
Sync Topics to Dashboard - Convert topics.json to topics.js for browser access
Part of: Hierarchical Multi-Agent Orchestration System v2.0.0 (Python)

This script converts topics.json (which browsers can't fetch via file://)
into topics.js (which browsers CAN load as a <script> tag).

Usage:
    python sync_topics_to_dashboard.py
    python sync_topics_to_dashboard.py --watch  # Auto-sync on changes
"""

import sys
import json
import time
from pathlib import Path
from datetime import datetime

# Import utilities
from utils import read_json_file, log_info, log_warn, log_error, ensure_directory


TOPICS_JSON = Path(".claude/agents/state/csprojecttask/topics.json")
DASHBOARD_DIR = Path("Project-tasks/csprojecttask-dashboard-v2/deliverables")
OUTPUT_JS = DASHBOARD_DIR / "data" / "topics.js"


def sync_topics() -> bool:
    """
    Convert topics.json → topics.js for browser loading

    Returns:
        True if successful, False otherwise
    """
    try:
        # Check if topics.json exists
        if not TOPICS_JSON.exists():
            log_warn(f"topics.json not found: {TOPICS_JSON}")
            log_info("Creating placeholder topics.js with empty data")

            # Create placeholder
            ensure_directory(OUTPUT_JS.parent)
            placeholder = """// topics.js - Auto-generated from topics.json
// Last updated: {timestamp}

const TOPICS_DATA = {{
  "version": "2.0.0",
  "lastUpdated": "{timestamp}",
  "topics": []
}};
""".format(timestamp=datetime.now().isoformat())

            OUTPUT_JS.write_text(placeholder, encoding='utf-8')
            log_info(f"Created placeholder: {OUTPUT_JS}")
            return True

        # Read topics.json
        data = read_json_file(TOPICS_JSON)
        if data is None:
            log_error(f"Failed to read topics.json")
            return False

        # Ensure output directory exists
        ensure_directory(OUTPUT_JS.parent)

        # Convert to JavaScript format
        js_content = f"""// topics.js - Auto-generated from topics.json
// Last updated: {datetime.now().isoformat()}
// DO NOT EDIT - This file is auto-generated by sync_topics_to_dashboard.py

const TOPICS_DATA = {json.dumps(data, indent=2)};
"""

        # Write topics.js
        OUTPUT_JS.write_text(js_content, encoding='utf-8')

        topic_count = len(data.get('topics', []))
        log_info(f"✓ Synced {topic_count} topics: {TOPICS_JSON} → {OUTPUT_JS}")
        return True

    except Exception as e:
        log_error(f"Failed to sync topics: {e}")
        return False


def watch_and_sync(interval: int = 2):
    """
    Watch topics.json for changes and auto-sync

    Args:
        interval: Check interval in seconds (default: 2)
    """
    log_info(f"Watching {TOPICS_JSON} for changes (interval: {interval}s)")
    log_info("Press Ctrl+C to stop")

    last_mtime = None

    try:
        while True:
            # Check if file exists and get modification time
            if TOPICS_JSON.exists():
                current_mtime = TOPICS_JSON.stat().st_mtime

                # If changed, sync
                if last_mtime is None or current_mtime != last_mtime:
                    if last_mtime is not None:
                        log_info("Change detected - syncing...")
                    sync_topics()
                    last_mtime = current_mtime
            else:
                # File doesn't exist yet
                if last_mtime is not None:
                    log_warn("topics.json disappeared - creating placeholder")
                    sync_topics()
                    last_mtime = None

            # Wait before next check
            time.sleep(interval)

    except KeyboardInterrupt:
        log_info("\nStopped watching")
        sys.exit(0)


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description='Sync topics.json to topics.js for browser access'
    )
    parser.add_argument(
        '--watch', '-w',
        action='store_true',
        help='Watch for changes and auto-sync'
    )
    parser.add_argument(
        '--interval', '-i',
        type=int,
        default=2,
        help='Watch interval in seconds (default: 2)'
    )

    args = parser.parse_args()

    if args.watch:
        # Initial sync
        sync_topics()
        # Start watching
        watch_and_sync(interval=args.interval)
    else:
        # One-time sync
        success = sync_topics()
        sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
